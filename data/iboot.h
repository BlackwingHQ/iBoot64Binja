#include <stdint.h>
/*
   This file has been generated by IDA.
   It contains local type definitions from
   the type library 'SecureROM'
*/

#define __int8 signed char
#define __uint8 unsigned char
#define __int16 short
#define __uint16 unsigned short
#define __int32 int
#define __uint32 unsigned int
#define __int64 long
#define __uint64 unsigned long

typedef __int8 int8_t;
typedef __uint8 uint8_t;
typedef __int16 int16_t;
typedef __uint16 uint16_t;
typedef __int32 int32_t;
typedef __uint32 uint32_t;
typedef __int64 int64_t;
typedef __uint64 uint64_t;

typedef long __signed;
typedef long intptr_t;
typedef void* addr_t;
typedef unsigned long uintptr_t;
typedef unsigned long size_t;
typedef long ssize_t;
typedef long time_t;

typedef __int8 SInt8;
typedef unsigned char UInt8;
typedef signed short SInt16;
typedef unsigned short UInt16;
typedef signed int SInt32;
typedef unsigned int UInt32;
typedef signed long long SInt64;
typedef unsigned long long UInt64;

typedef int	vm_prot_t;

struct boot_interface_pin {
    uint32_t      pin;
    uint32_t enable;
    uint32_t disable;
};

/* 2 */
#pragma pack(push, 8)
struct __attribute__((aligned(4))) segment_command
{
  uint32_t cmd;
  uint32_t cmdsize;
  char segname[16];
  uint32_t vmaddr;
  uint32_t vmsize;
  uint32_t fileoff;
  uint32_t filesize;
  vm_prot_t maxprot;
  vm_prot_t initprot;
  uint32_t nsects;
  uint32_t flags;
};
#pragma pack(pop)

/* 3 */
#pragma pack(push, 8)
struct __attribute__((aligned(4))) section
{
  char sectname[16];
  char segname[16];
  uint32_t addr;
  uint32_t size;
  uint32_t offset;
  uint32_t align;
  uint32_t reloff;
  uint32_t nreloc;
  uint32_t flags;
  uint32_t reserved1;
  uint32_t reserved2;
};
#pragma pack(pop)



/* 14 */
typedef enum
{
  kMemoryRegion_StorageProcessor = 0x0,
  kMemoryRegion_ConsistentDebug = 0x1,
  kMemoryRegion_SleepToken = 0x2,
  kMemoryRegion_DramConfig = 0x3,
  kMemoryRegion_Panic = 0x4,
  kMemoryRegion_Display = 0x5,
  kMemoryRegion_Heap = 0x6,
  kMemoryRegion_Stacks = 0x7,
  kMemoryRegion_PageTables = 0x8,
  kMemoryRegion_iBoot = 0x9,
  kMemoryRegion_Kernel = 0xA,
  kMemoryRegion_Monitor = 0xB,
  kMemoryRegion_SecureProcessor = 0xC,
  kMemoryRegion_AOP = 0xD,
  kMemoryRegion_Reconfig = 0xE,
  kMemoryRegion_NumberOfRegions = 0xF,
} memory_region_type_t;

/* 16 */
typedef enum
{
  kUSB_DP = 0x1,
  kUSB_DM = 0x2,
  kUSB_NONE = 0x0,
  kUSB_DCD = 0x3,
  kUSB_CP1 = 0x4,
  kUSB_CP2 = 0x5,
} usb_c_alternate_mode_t;

/* 17 */
struct _CBUFFER
{
  uint8_t *head;
  uint8_t *tail;
  size_t size;
  size_t readableSize;
  size_t bufferSize;
  uint8_t *dataStart;
  uint8_t *dataEnd;
};

/* 18 */
typedef struct _CBUFFER CBUFFER;

/* 19 */
struct list_node
{
  struct list_node *prev;
  struct list_node *next;
};

/* 20 */
enum target_property
{
  TARGET_PROEPRTY_NONE = 0x0,
  TARGET_PROPERTY_WIFI_MACADDR = 0x1,
  TARGET_PROPERTY_WIFI_CALIBRATION_TX = 0x2,
  TARGET_PROPERTY_WIFI_CALIBRATION_TX_24 = 0x3,
  TARGET_PROPERTY_WIFI_CALIBRATION_TX_50 = 0x4,
  TARGET_PROPERTY_WIFI_CALIBRATION_RX_24 = 0x5,
  TARGET_PROPERTY_WIFI_CALIBRATION_RX_50 = 0x6,
  TARGET_PROPERTY_WIFI_CALIBRATION_RX_TEMP = 0x7,
  TARGET_PROPERTY_WIFI_CALIBRATION_FREQ_GROUP_2G = 0x8,
  TARGET_PROPERTY_WIFI_BOARD_SNUM = 0x9,
  TARGET_PROPERTY_WIFI_WCAL = 0xA,
  TARGET_PROPERTY_BT_MACADDR = 0xB,
  TARGET_PROPERTY_ETH_MACADDR = 0xC,
  TARGET_PROPERTY_BB_REGION_SKU = 0xD,
  TARGET_PROPERTY_RESTORE_BACKLIGHT_LEVEL = 0xE,
  TARGET_PROPERTY_PINTO_MACADDR = 0xF,
  TARGET_PROPERTY_WIFI1_MACADDR = 0x10,
  TARGET_PROPERTY_BT1_MACADDR = 0x11,
  TARGET_PROPERTY_ETH1_MACADDR = 0x12,
  TARGET_PROPERTY_BLUETOOTH_DEV_MACADDR0 = 0x13,
  TARGET_PROPERTY_MAX = 0x14,
};

/* 22 */
enum boot_device
{
  BOOT_DEVICE_NOR = 0x0,
  BOOT_DEVICE_SPI = 0x1,
  BOOT_DEVICE_NAND = 0x2,
  BOOT_DEVICE_NVME = 0x3,
  BOOT_DEVICE_USBDFU = 0x4,
  BOOT_DEVICE_TBTDFU = 0x5,
  BOOT_DEVICE_XMODEM = 0x6,
};

/* 23 */
enum colorspace
{
  CS_4BPP = 0x0,
  CS_8BPP = 0x1,
  CS_RGB332 = 0x2,
  CS_RGB565 = 0x3,
  CS_ARGB1555 = 0x4,
  CS_ARGB4444 = 0x5,
  CS_RGB888 = 0x6,
  CS_ARGB8888 = 0x7,
  CS_ARGB8101010 = 0x8,
};

/* 24 */
struct syscfg_wpcl
{
  uint32_t version;
  uint32_t red;
  uint32_t green;
  uint32_t blue;
};

/* 25 */
struct syscfg_DCLr_RGB
{
  uint8_t blue;
  uint8_t green;
  uint8_t red;
  uint8_t reserved;
};

/* 26 */
union syscfg_rgb_or_DCLr
{
  uint32_t rgb;
  struct syscfg_DCLr_RGB component;
};

/* 27 */
struct syscfg_DClr
{
  uint8_t minor_version;
  uint8_t major_version;
  uint8_t reserved_2;
  uint8_t reserved_3;
  union syscfg_rgb_or_DCLr device_enclosure;
  union syscfg_rgb_or_DCLr cover_glass;
  uint8_t reserved_C;
  uint8_t reserved_D;
  uint8_t reserved_E;
  uint8_t reserved_F;
};

/* 28 */
typedef struct syscfg_DClr syscfg_DClr_t;

/* 29 */
typedef enum
{
  clrcColorUnknown = 0xFFFFFFFF,
  clrcColorBlack = 0x0,
  clrcColorWhite = 0x1,
  clrcColorRed = 0x2,
  clrcColorSilver = 0x3,
  clrcColorPink = 0x4,
  clrcColorBlue = 0x5,
  clrcColorYellow = 0x6,
  clrcColorGold = 0x7,
  clrcColorSparrow = 0x8,
  clrcColorCount = 0x9,
} clrcColor;

/* 31 */
struct syscfg_ClrC
{
  uint8_t clrcColor;
  uint8_t reserved[15];
};

/* 32 */
typedef struct syscfg_ClrC syscfg_ClrC_t;

/* 33 */
enum color_map_policy
{
  COLOR_MAP_POLICY_NONE = 0x0,
  COLOR_MAP_POLICY_INVERT = 0x1,
};

/* 34 */
typedef uint32_t (__cdecl *map_color_t)(uint64_t color);

/* 35 */
struct color_policy
{
  enum color_map_policy policy_type;
  void *color_table;
  uint32_t color_count;
  map_color_t map_color;
};

/* 36 */
typedef struct color_policy color_policy_t;

/* 37 */
struct color_policy_invert
{
  uint32_t cover_glass;
  char invert;
};

/* 38 */
typedef struct color_policy_invert color_policy_invert_t;

/* 39 */
struct plane
{
  enum colorspace cs;
  void *fb_virt;
  void *db_virt;
  uint32_t plane_size;
  uint32_t pixel_size;
  uint32_t pixel_size_per_channel;
  uint32_t line_x;
  uint32_t width;
  uint32_t height;
  uint32_t stride;
  void (__cdecl *plot)(struct plane *p, uint32_t x, uint32_t y, uint64_t color);
  uint32_t (__cdecl *get_pixel)(struct plane *p, uint32_t x, uint32_t y);
  void (__cdecl *hline)(struct plane *p, uint32_t x, uint32_t y, uint32_t len, uint64_t color);
  void (__cdecl *vline)(struct plane *p, uint32_t x, uint32_t y, uint32_t len, uint64_t color);
};

/* 40 */
struct canvas
{
  enum colorspace cs;
  struct plane planes[2];
  uint32_t num_of_active_planes;
  void *fb_virt;
  uintptr_t fb_phys;
  uint32_t x;
  uint32_t y;
  map_color_t map_color;
};

/* 41 */
struct syscfgEntry
{
  uint32_t seTag;
  uint8_t seData[16];
};

/* 42 */
struct syscfgEntryCNTB
{
  uint32_t seTag;
  uint32_t seRealTag;
  uint32_t seDataSize;
  uint32_t seDataOffset;
  uint32_t reserved;
};

/* 43 */
struct syscfgMemEntry
{
  uint32_t seTag;
  uint8_t seData[16];
  uint32_t seDataSize;
  uint32_t seDataOffset;
};

/* 44 */
struct arp_cache_entry
{
  uint32_t ip;
  char mac[6];
  struct arp_cache_entry *next;
};

/* 45 */
typedef struct arp_cache_entry arp_cache_entry_t;

/* 46 */
struct arp_cache
{
  arp_cache_entry_t cache[32];
};

/* 47 */
typedef struct arp_cache arp_cache_t;

/* 49 */
typedef int (__cdecl *callback_handler)(char *data, int offset, int len, void *prevlayerdata);

/* 48 */
struct listentry
{
  int cb_id;
  int port;
  callback_handler callback;
  struct listentry *next;
};

/* 50 */
typedef struct listentry listentry_t;

/* 51 */
struct callbacks
{
  listentry_t *first;
};

/* 52 */
typedef struct callbacks callbacks_t;

/* 53 */
struct mbufentry
{
  int flag;
  int len;
  char *data;
  struct mbufentry *next;
};

/* 54 */
typedef struct mbufentry mbufentry_t;

/* 55 */
struct mymbuf
{
  mbufentry_t *first;
  int allocated_length;
  int current_length;
  char *primarydata;
  int offset;
};

/* 56 */
typedef struct mymbuf mymbuf_t;

/* 57 */
struct udpinfo
{
  uint32_t srcip;
  uint16_t srcport;
  uint16_t length;
};

/* 58 */
typedef struct udpinfo udpinfo_t;

/* 59 */
struct __attribute__((packed)) usb_device_request
{
  uint8_t bmRequestType;
  uint8_t bRequest;
  uint16_t wValue;
  uint16_t wIndex;
  uint16_t wLength;
};

/* 60 */
struct __attribute__((packed)) usb_configuration_descriptor
{
  uint8_t bLength;
  uint8_t bDescriptorType;
  uint16_t wTotalLength;
  uint8_t bNumInterfaces;
  uint8_t bConfigurationValue;
  uint8_t iConfiguration;
  uint8_t bmAttributes;
  uint8_t bMaxPower;
};

/* 61 */
struct __attribute__((packed)) usb_interface_descriptor
{
  uint8_t bLength;
  uint8_t bDescriptorType;
  uint8_t bInterfaceNumber;
  uint8_t bAlternateSetting;
  uint8_t bNumEndpoints;
  uint8_t bInterfaceClass;
  uint8_t bInterfaceSubClass;
  uint8_t bInterfaceProtocol;
  uint8_t iInterface;
};

/* 62 */
struct __attribute__((packed)) usb_endpoint_descriptor
{
  uint8_t bLength;
  uint8_t bDescriptorType;
  uint8_t bEndpointAddress;
  uint8_t bmAttributes;
  uint16_t wMaxPacketSize;
  uint8_t bInterval;
};

/* 63 */
struct __attribute__((packed)) usb_string_descriptor
{
  uint8_t bLength;
  uint8_t bDescriptorType;
  uint8_t wData[2];
};

/* 64 */
struct __attribute__((packed)) usb_device_qualifier_descriptor
{
  uint8_t bLength;
  uint8_t bDescriptorType;
  uint16_t bcdUSB;
  uint8_t bDeviceClass;
  uint8_t bDeviceSubClass;
  uint8_t bDeviceProtocol;
  uint8_t bMaxPacketSize0;
  uint8_t bNumConfigurations;
  uint8_t bReserved;
};

/* 65 */
enum $133797FAFDC15CE16E86A53C330F0D80
{
  DEVICE_ST_UNKNOWN = 0xFFFFFFFF,
  DEVICE_ST_INIT = 0x0,
  DEVICE_ST_ATTACHED = 0x1,
  DEVICE_ST_POWERED = 0x2,
  DEVICE_ST_DEFAULT = 0x3,
  DEVICE_ST_ADDRESSED = 0x4,
  DEVICE_ST_CONFIGURED = 0x5,
  DEVICE_ST_SUSPENDED = 0x6,
};

/* 66 */
enum urb_result
{
  USB_IO_ERROR = 0xFFFFFFFF,
  USB_IO_SUCCESS = 0x0,
  USB_IO_ABORTED = 0x1,
};

/* 67 */
enum usb_controller_state
{
  CABLE_CONNECTED = 0x0,
  CABLE_DISCONNECTED = 0x1,
  USB_RESET = 0x2,
  USB_ENUM_DONE = 0x3,
};

/* 68 */
enum usb_controller_speed
{
  CONNECTION_SPEED_FULL = 0x0,
  CONNECTION_SPEED_HIGH = 0x1,
};

/* 69 */
struct usb_device_io_request
{
  uint32_t endpoint;
  volatile uint8_t *io_buffer;
  int status;
  int io_length;
  int return_count;
  void (__cdecl *callback)(struct usb_device_io_request *io_request);
  struct usb_device_io_request *next;
};

/* 70 */
#pragma pack(push, 8)
struct __attribute__((aligned(4))) usb_endpoint_instance
{
  int endpoint_address;
  int max_packet_size;
  int attributes;
  int bInterval;
  int transfer_size;
  int packet_count;
  struct usb_endpoint_instance *next_ep;
  struct usb_device_io_request *io_head;
  struct usb_device_io_request *io_tail;
  usb_device_io_request *completion_head;
  usb_device_io_request *completion_tail;
  int tx_fifo_number;
};
#pragma pack(pop)

/* 71 */
struct usb_controller_ops
{
  void (*start)(void);
  void (*stop)(void);
  void (__cdecl *set_address)(int new_address);
  void (__cdecl *stall_endpoint)(uint32_t endpoint, char stall);
  void (__cdecl *reset_endpoint_data_toggle)(uint32_t endpoint);
  char (__cdecl *is_endpoint_stalled)(uint32_t endpoint);
  void (__cdecl *do_endpoint_io)(struct usb_device_io_request *req);
  void (__cdecl *activate_endpoint)(uint32_t endpoint, int type, int max_packet_size, int interval);
  void (__cdecl *deactivate_endpoint)(uint32_t endpoint);
  void (__cdecl *abort_endpoint)(uint32_t endpoint);
  void (__cdecl *do_test_mode)(int test_selector);
  int (*get_connection_speed)(void);
};

/* 72 */
struct usb_interface_instance
{
  int (__cdecl *interface_request_handler)(struct usb_device_request *request, uint8_t **out_data);
  void (__cdecl *non_setup_data_phase_finished_callback)(int data_rcvd);
  void (*activate_interface)(void);
  void (*bus_reset_handler)(void);
  int (*get_interface_handler)(void);
  int (__cdecl *set_interface_handler)(int alt_setting);
};

/* 73 */
enum $DECF713954B0078708B1A12E757F48B0
{
  USB_CONTROLLER_synopsys_otg = 0x0,
  USB_CONTROLLER_dbgfifo = 0x1,
};

/* 74 */
typedef enum $DECF713954B0078708B1A12E757F48B0 USB_CONTROLLER_T;

/* 75 */
struct usb_controller_functions
{
  int (*init)(void);
  void (*free_func)(void);
  int (*start)(void);
  void (*stop)(void);
  void (__cdecl *set_address)(uint32_t new_address);
  int (*get_connection_speed)(void);
  void (__cdecl *activate_endpoint)(uint32_t endpoint, int type, int max_packet_size, int interval);
  void (__cdecl *do_endpoint_io)(struct usb_device_io_request *req);
  void (__cdecl *stall_endpoint)(uint32_t endpoint, char stall);
  void (__cdecl *reset_endpoint_data_toggle)(uint32_t endpoint);
  char (__cdecl *is_endpoint_stalled)(uint32_t endpoint);
  void (__cdecl *do_test_mode)(uint32_t selector);
  void (__cdecl *abort_endpoint)(uint32_t endpoint);
  void (__cdecl *deactivate_endpoint)(uint32_t endpoint);
};

/* 76 */
enum $AADE32B6E2B5001E704E6B4D7B1C4C38
{
  USB_TRANSFER_TYPE_DFU_GET = 0x0,
  USB_TRANSFER_TYPE_DFU_PUT = 0x1,
  USB_TRANSFER_TYPE_BULK_GET = 0x2,
  USB_TRANSFER_TYPE_BULK_PUT = 0x3,
};

/* 77 */
struct nhi_sgl
{
  void *buffer;
  uint32_t bytes;
  struct nhi_sgl *next;
};

/* 78 */
typedef struct nhi_sgl nhi_sgl_t;

/* 80 */
typedef int integer_t;

/* 83 */
typedef unsigned int __darwin_natural_t;

/* 82 */
typedef __darwin_natural_t natural_t;

/* 81 */
typedef natural_t vm_size_t;

/* 79 */
struct zone_info
{
  integer_t zi_count;
  vm_size_t zi_cur_size;
  vm_size_t zi_max_size;
  vm_size_t zi_elem_size;
  vm_size_t zi_alloc_size;
  integer_t zi_pageable;
  integer_t zi_sleepable;
  integer_t zi_exhaustible;
  integer_t zi_collectable;
};

/* 84 */
#pragma pack(push, 8)
struct usb_device_descriptor
{
  uint8_t bLength;
  uint8_t bDescriptorType;
  uint16_t idProduct;
  uint8_t bcdDevice;
  uint8_t bDeviceSubClass;
  uint8_t iManufacturer;
  uint8_t iProduct;
  uint16_t iSerialNumber;
  uint16_t b;
  uint16_t n;
  uint8_t c;
  uint8_t d;
  uint8_t e;
  uint8_t bNumConfigurations;
};
#pragma pack(pop)

/* 85 */
enum bool_t
{
  FALSE = 0x0,
  TRUE = 0x1,
};

/* 86 */
union __attribute__((aligned(8))) __n64
{
  unsigned __int64 n64_u64[1];
  unsigned __int32 n64_u32[2];
  unsigned __int16 n64_u16[4];
  __int8 n64_u8[8];
  __int64 n64_i64[1];
  __int32 n64_i32[2];
  __int16 n64_i16[4];
  __int8 n64_i8[8];
  float n64_f32[2];
  double n64_f64[1];
};

/* 87 */
union __attribute__((aligned(8))) __n128
{
  unsigned __int64 n128_u64[2];
  unsigned __int32 n128_u32[4];
  unsigned __int16 n128_u16[8];
  __int8 n128_u8[16];
  __int64 n128_i64[2];
  __int32 n128_i32[4];
  __int16 n128_i16[8];
  __int8 n128_i8[16];
  float n128_f32[4];
  double n128_f64[2];
};

/* 88 */
typedef __n128 float64x2_t;

/* 89 */
typedef __n128 poly128_t;

/* 90 */
enum boot_target
{
  BOOT_UNKOWN = 0x0,
  BOOT_HALT = 0x1,
  BOOT_IBOOT = 0x2,
  BOOT_DARWIN = 0x3,
  BOOT_DARWIN_RESTORE = 0x4,
  BOOT_DIAGS = 0x5,
  BOOT_TSYS = 0x6,
  BOOT_SECUREROM = 0x7,
  BOOT_MONITOR = 0x8,
  BOOT_DALI = 0x9,
};

/* 92 */
#pragma pack(push, 8)
struct mem_static_map_entry
{
  int cached_base;
  int uncached_base;
  int physical_team;
  int size;
};
#pragma pack(pop)

/* 93 */
#pragma pack(push, 8)
struct image_info
{
  int imageLength;
  int imageAllocation;
  int imageType;
  int imagePrivateMagic;
  int imageOptions;
  int imagePrivate;
};
#pragma pack(pop)

/* 94 */
#pragma pack(push, 8)
struct task_wait_queue
{
  list_node task_list;
};
#pragma pack(pop)

/* 95 */
#pragma pack(push, 8)
struct __attribute__((packed)) __attribute__((aligned(2))) task_event
{
  char signaled;
  char flags;
  task_wait_queue wait;
};
#pragma pack(pop)

/* 96 */
#pragma pack(push, 8)
struct __attribute__((packed)) __attribute__((aligned(1))) akf_wrapper
{
  int base;
  __int16 clock_idx;
  __int16 inbox_int;
  __int16 outbox_int;
  task_event recv_mbox_wait_event;
  task_event send_mbox_wait_event;
  char set_iop_timebase;
};
#pragma pack(pop)

typedef struct {
    char* build_banner_string;
    char*	build_style_string;
    char* build_tag_string;
    void* text_base;
    void* text_end;
    size_t text_size;
    void* data_ro_start;
    void* data_base;
    size_t data_size;
    void* bss_start;
    void* bss_end;
    void* stack_base;
    size_t stack_size;
    void* page_table_base;
    size_t page_table_size;
    void* heap_guard;
    void* boot_handoff_trampoline;
    void* boot_handoff_trampoline_end;
    void* boot_trampoline_base;
    void*	interrupt_stack_top;
} rom64_descriptor_t;


uint64_t arm_read_sctlr();
void arm_write_sctlr(uint64_t sctlr);
void arm_write_scr(uint64_t scr);
uint64_t arm_read_l2_cramconfig();
void arm_write_mair(uint64_t mair);
void arm_write_tcr(uint64_t tcr);
void arm_write_ttbr0(uint64_t ttbr0);
uint64_t arm_read_cpacr();
void arm_write_cpacr(uint64_t cpacr);
uint64_t arm_read_cntp_ctl();
void arm_write_cntp_ctl(uint64_t cntp_ctl);
uint64_t arm_read_cntpct();
void arm_write_cntp_tval(uint64_t cntp_tval);
void arm_flush_tlbs();
void arm_invalidate_icache();
void arm_invalidate_dcache_line() {}
void arm_clean_dcache_line() {}
void arm_clean_invalidate_dcache() {}
void arm_clean_dcache() {}
void arm_invalidate_dcache() {}
void arm_clean_invalidate_dcache_line(void* address);
void arm_drain_write_buffer() {}
void arm_memory_barrier();
void arm_vtop();
void arm_disable_async_aborts();
void arm_enable_async_aborts();
void arch_disable_ints();
void arch_enable_ints();
void arch_halt();
void arch_spin();
void arch_task_context_switch();
void arch_task_context_restore();
void start();

void arch_task_trampoline();
void arch_task_trampoline();
int arch_task_create(struct task *task_obj);

static uint64_t *tt_top_level;

void mmu_printf(int verbosity, const char *format, ...);
unsigned get_page_granule_shift();
void get_table_entry_hook(unsigned level, addr_t table_base, size_t index);
void assert_valid_level(unsigned level);
bool level_permits_blocks(unsigned level);
uint64_t get_table_entry(unsigned level, addr_t table_base, size_t index);
void set_table_entry(unsigned level, addr_t table_base, size_t index, uint64_t value);
unsigned get_start_level();
unsigned get_virt_address_bits();


typedef struct {
    void* text_base;
    void* text_end;
    size_t text_size;
    void* data_ro_start;
    void* data_base;
    void* data_end;
    void* bss_start;
    void* bss_end;
    void* stacks_base;
    size_t stacks_size;
    void* page_tables_base;
    size_t page_tables_size;
#ifdef HEAP_GUARD
    void* heap_guard;
#endif
#ifdef BOOT_TRAMPOLINE_BASE
    void* boot_handoff_trampoline
    void* boot_handoff_trampoline_end
    void* boot_trampoline_base;
#endif
} iboot_aarch64_rom_t;
